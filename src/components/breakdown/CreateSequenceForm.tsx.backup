'use client'

import { useState, useEffect } from 'react'
import { useRouter } from 'next/navigation'
import toast from 'react-hot-toast'
import { sessionStore } from '@/lib/sessionStore-mock'
import { useCurrentProject } from '@/lib/currentProject-supabase'
import { useSequences } from '@/hooks/useSequences'
import { FooterProvider } from '@/contexts/FooterContext'
import StepHeader from './StepHeader'
import StepFooter from './StepFooter'
import GeneralStep from './steps/GeneralStep'
import RoleStep from './steps/RoleStep'
import CostumeStep from './steps/CostumeStep'
import AccessoireStep from './steps/AccessoireStep'
import { EffetsSpeciauxStep } from './steps/EffetsSpeciauxStep'
import { EquipesTechniquesStep } from './steps/EquipesTechniquesStep'
import SonStep from './steps/SonStep'
import MachinerieStep from './steps/MachinerieStep'

const STEPS = [
  "Général",
  "Rôle",
  "Costume",
  "Accessoire",
  "Effets spéciaux",
  "Équipe technique",
  "Son",
  "Machinerie",
] as const

type StepKey = typeof STEPS[number]

interface CreateSequenceFormProps {
  onCancel: () => void
  editMode?: boolean
  sequenceId?: string
}

export default function CreateSequenceForm({ onCancel, editMode = false, sequenceId }: CreateSequenceFormProps) {
  const router = useRouter()
  const { project } = useCurrentProject()
  const { sequences, createSequence, updateSequence } = useSequences(project?.id)
  const [currentStep, setCurrentStep] = useState<StepKey>("Général")
  const [createdSequenceId, setCreatedSequenceId] = useState<string | null>(sequenceId || null)
  const [formData, setFormData] = useState({
    code: '',
    title: '',
    colorId: 'blue',
    status: 'En attente',
    location: '',
    summary: '',
    preMintage: '00:00',
    ett: '00:00',
    effet: 'JOUR',
    type: 'INT'
  })
  const [showSuccess, setShowSuccess] = useState(false)

  // Créer immédiatement une séquence vide en mode création
  useEffect(() => {
    const createInitialSequence = async () => {
      // Si mode création (pas d'edition et pas d'ID fourni) et qu'on a un projet
      if (!editMode && !sequenceId && !createdSequenceId && project?.id) {
        try {
          const newSequence = await createSequence({
            project_id: project.id,
            title: 'Nouvelle séquence',
            color_id: 'blue',
            status: 'En attente',
          })
          
          if (newSequence) {
            setCreatedSequenceId(newSequence.id)
            console.log('Séquence créée automatiquement:', newSequence.id)
          }
        } catch (error) {
          console.error('Erreur lors de la création initiale:', error)
        }
      }
    }

    createInitialSequence()
  }, [editMode, sequenceId, createdSequenceId, project?.id, createSequence])

  // Fonction simple pour mettre à jour le titre (plus de création automatique)
  const handleTitleChange = (newTitle: string) => {
    setFormData({ ...formData, title: newTitle })
  }

  // Charger les données en mode édition depuis Supabase
  useEffect(() => {
    if (editMode && sequenceId && sequences.length > 0) {
      const sequence = sequences.find(s => s.id === sequenceId)
      if (sequence) {
        setFormData({
          code: sequence.code || 'SEQ-1',
          title: sequence.title,
          colorId: sequence.color_id || 'blue',
          status: sequence.status || 'A validé',
          location: sequence.location || '',
          summary: sequence.summary || '',
          preMintage: sequence.pre_montage || '00:00',
          ett: sequence.ett || '00:00',
          effet: sequence.time_of_day || 'JOUR',
          type: sequence.location_type || 'INT'
        })
      }
    }
  }, [editMode, sequenceId, sequences])

  const currentIndex = STEPS.indexOf(currentStep)

  const goNext = () => {
    if (currentIndex < STEPS.length - 1) {
      setCurrentStep(STEPS[currentIndex + 1])
    }
  }

  const goPrev = () => {
    if (currentIndex > 0) {
      setCurrentStep(STEPS[currentIndex - 1])
    }
  }

  const goTo = (step: StepKey) => {
    setCurrentStep(step)
  }

  const handleSubmit = async (e?: React.FormEvent) => {
    if (e) e.preventDefault()
    
    const loadingToast = toast.loading('Sauvegarde de la séquence...')
    
    try {
      // Toujours mettre à jour la séquence existante (créée automatiquement ou fournie)
      const sequenceIdToUpdate = editMode ? sequenceId : createdSequenceId
      
      if (sequenceIdToUpdate && updateSequence) {
        const updatedSequence = await updateSequence(sequenceIdToUpdate, {
          title: formData.title,
          color_id: formData.colorId,
          status: formData.status as any,
          location: formData.location,
          summary: formData.summary,
          pre_montage: formData.preMintage,
          ett: formData.ett,
          time_of_day: formData.effet as any,
          location_type: formData.type as any
        })
        
        if (updatedSequence) {
          toast.success(`Séquence "${formData.title}" sauvegardée avec succès`, {
            id: loadingToast,
          })
          setShowSuccess(true)
          console.log('Séquence sauvegardée:', updatedSequence)
          
          setTimeout(() => {
            setShowSuccess(false)
          }, 1000)
        }
      } else {
        throw new Error('Aucune séquence à mettre à jour')
      }
    } catch (error) {
      console.error('Erreur lors de la sauvegarde:', error)
      toast.error('Erreur lors de la sauvegarde de la séquence', {
        id: loadingToast,
      })
    }
  }

  const renderStepContent = () => {
    // Utiliser l'ID de séquence créée ou fourni en prop
    const currentSequenceId = createdSequenceId || sequenceId
    
    switch (currentStep) {
      case "Général":
        return (
          <GeneralStep 
            formData={formData} 
            setFormData={setFormData}
            showSuccess={showSuccess}
            sequenceId={currentSequenceId}
            onTitleChange={handleTitleChange}
          />
        )
      case "Rôle":
        return <RoleStep sequenceId={currentSequenceId} />
      case "Costume":
        return <CostumeStep sequenceId={currentSequenceId || ''} />
      case "Accessoire":
        return <AccessoireStep sequenceId={currentSequenceId || ''} />
      case "Effets spéciaux":
        return <EffetsSpeciauxStep sequenceId={currentSequenceId || ''} />
      case "Équipe technique":
        return <EquipesTechniquesStep sequenceId={currentSequenceId || ''} />
      case "Son":
        return <SonStep sequenceId={currentSequenceId || ''} />
      case "Machinerie":
        return <MachinerieStep sequenceId={currentSequenceId || ''} />
      default:
        return <GeneralStep formData={formData} setFormData={setFormData} showSuccess={showSuccess} sequenceId={currentSequenceId} />
    }
  }

  return (
    <FooterProvider>
      <div className="bg-slate-800 rounded-lg h-full flex flex-col">
        {/* Header */}
        <div className="flex-shrink-0 p-4 md:p-6 border-b border-slate-600">
          <div className="flex items-center justify-between">
            <StepHeader
              current={currentStep}
              steps={STEPS}
              onSelect={goTo}
              onClose={onCancel}
            />
          </div>
        </div>

        {/* Content - Scrollable */}
        <div className="flex-1 overflow-y-auto p-4 md:p-6">
          {renderStepContent()}
        </div>

        {/* Footer */}
        <div className="flex-shrink-0 p-4 md:p-6 border-t border-slate-600">
          <StepFooter
            currentIndex={currentIndex}
            total={STEPS.length}
            onPrev={goPrev}
            onNext={goNext}
            onSubmit={handleSubmit}
            editMode={editMode}
          />
        </div>
      </div>
    </FooterProvider>
  )
}
    location: '',
    summary: '',
    preMintage: '00:00',
    ett: '00:00',
    effet: 'JOUR',
    type: 'INT'
  })
  const [showSuccess, setShowSuccess] = useState(false)

  // Créer immédiatement une séquence vide en mode création
  useEffect(() => {
    const createInitialSequence = async () => {
      // Si mode création (pas d'edition et pas d'ID fourni) et qu'on a un projet
      if (!editMode && !sequenceId && !createdSequenceId && project?.id) {
        try {
          const newSequence = await createSequence({
            project_id: project.id,
            title: 'Nouvelle séquence',
            color_id: 'blue',
            status: 'En attente',
          })
          
          if (newSequence) {
            setCreatedSequenceId(newSequence.id)
            console.log('Séquence créée automatiquement:', newSequence.id)
          }
        } catch (error) {
          console.error('Erreur lors de la création initiale:', error)
        }
      }
    }

    createInitialSequence()
  }, [editMode, sequenceId, createdSequenceId, project?.id, createSequence])

  // Fonction simple pour mettre à jour le titre (plus de création automatique)
  const handleTitleChange = (newTitle: string) => {
    setFormData({ ...formData, title: newTitle })
  }

  // Charger les données en mode édition
  // Charger les données en mode édition depuis Supabase
  useEffect(() => {
    if (editMode && sequenceId && sequences.length > 0) {
      const sequence = sequences.find(s => s.id === sequenceId)
      if (sequence) {
        setFormData({
          code: sequence.code || 'SEQ-1',
          title: sequence.title,
          colorId: sequence.color_id || 'blue',
          status: sequence.status || 'A validé',
          location: sequence.location || '',
          summary: sequence.summary || '',
          preMintage: sequence.pre_montage || '00:00',
          ett: sequence.ett || '00:00',
          effet: sequence.time_of_day || 'JOUR',
          type: sequence.location_type || 'INT'
        })
      }
    }
  }, [editMode, sequenceId, sequences])

  const currentIndex = STEPS.indexOf(currentStep)

  // Debug: afficher l'état actuel
  const currentSequence = sessionStore.getCurrentSequence()
  console.log('État actuel du stepper:', {
    currentStep,
    currentSequence: currentSequence ? {
      id: currentSequence.id,
      title: currentSequence.title,
      decorsCount: sessionStore.getDecors(currentSequence.id).length,
      scenesCount: sessionStore.getScenes(currentSequence.id).length
    } : 'Aucune séquence courante',
    formData
  })

  const goNext = () => {
    if (currentIndex < STEPS.length - 1) {
      setCurrentStep(STEPS[currentIndex + 1])
    }
  }

  const goPrev = () => {
    if (currentIndex > 0) {
      setCurrentStep(STEPS[currentIndex - 1])
    }
  }

  const goTo = (step: StepKey) => {
    setCurrentStep(step)
  }

  // Fonction de debug pour vérifier les données
  const debugSequence = () => {
    const allSequences = sessionStore.getSequences()
    const current = sessionStore.getCurrentSequence()
    console.log('=== DEBUG SEQUENCE ===')
    console.log('Toutes les séquences:', allSequences)
    console.log('Séquence courante:', current)
    console.log('FormData:', formData)
    console.log('======================')
  }

  const handleSubmit = async (e?: React.FormEvent) => {
    if (e) e.preventDefault()
    
    const loadingToast = toast.loading('Sauvegarde de la séquence...')
    
    try {
      // Toujours mettre à jour la séquence existante (créée automatiquement ou fournie)
      const sequenceIdToUpdate = editMode ? sequenceId : createdSequenceId
      
      if (sequenceIdToUpdate && updateSequence) {
        const updatedSequence = await updateSequence(sequenceIdToUpdate, {
          title: formData.title,
          color_id: formData.colorId,
          status: formData.status as any,
          location: formData.location,
          summary: formData.summary,
          pre_montage: formData.preMintage,
          ett: formData.ett,
          time_of_day: formData.effet as any,
          location_type: formData.type as any
        })
        
        if (updatedSequence) {
          toast.success(`Séquence "${formData.title}" sauvegardée avec succès`, {
            id: loadingToast,
          })
          setShowSuccess(true)
          console.log('Séquence sauvegardée:', updatedSequence)
          
          setTimeout(() => {
            setShowSuccess(false)
          }, 1000)
        }
      } else {
        throw new Error('Aucune séquence à mettre à jour')
      }
          ett: formData.ett,
          time_of_day: formData.effet as any,
          location_type: formData.type as any
        })
        
        if (updatedSequence) {
          toast.success(`Séquence "${formData.title}" modifiée avec succès`, {
            id: loadingToast,
          })
          setShowSuccess(true)
          console.log('Séquence mise à jour:', updatedSequence)
          
          setTimeout(() => {
            setShowSuccess(false)
            // Ne pas rediriger pour permettre l'édition des décors/scènes
          }, 1000)
        }
      }
      // Mode création : créer une nouvelle séquence
      else if (project?.id && createSequence) {
        const newSequence = await createSequence({
          project_id: project.id,
          title: formData.title,
          color_id: formData.colorId,
          status: formData.status as any,
          location: formData.location,
          summary: formData.summary,
          pre_montage: formData.preMintage,
          ett: formData.ett,
          time_of_day: formData.effet as any,
          location_type: formData.type as any
        })
        
        if (newSequence) {
          setCreatedSequenceId(newSequence.id) // Permettre l'accès aux décors/scènes
          toast.success(`Séquence "${formData.title}" créée avec succès`, {
            id: loadingToast,
          })
          setShowSuccess(true)
          console.log('Nouvelle séquence créée:', newSequence)
          
          setTimeout(() => {
            setShowSuccess(false)
            // Ne pas rediriger automatiquement
          }, 1000)
        }
      }
      // Fallback sur sessionStore si nécessaire
      else {
        const currentSequence = sessionStore.getCurrentSequence()
        
        if (currentSequence) {
          const updatedSequence = sessionStore.updateSequence(currentSequence.id, {
            code: formData.code,
            title: formData.title,
            colorId: formData.colorId,
            status: formData.status as any,
            location: formData.location,
            summary: formData.summary,
            preMintage: formData.preMintage,
            ett: formData.ett,
            effet: formData.effet as any,
            type: formData.type as any
          })
          
          if (updatedSequence) {
            setShowSuccess(true)
            const stats = sessionStore.getSequenceStats(updatedSequence.id)
            console.log('Séquence créée/mise à jour:', {
              ...updatedSequence,
              totalDecors: stats.decorsCount,
              totalScenes: stats.scenesCount
            })
            
            setTimeout(() => {
              setShowSuccess(false)
              router.push('/sequences')
            }, 1000)
          }
        } else {
          const newSequence = sessionStore.createSequence({
            code: formData.code,
            title: formData.title,
            colorId: formData.colorId,
            status: formData.status as any,
            location: formData.location,
            summary: formData.summary,
            preMintage: formData.preMintage,
            ett: formData.ett,
            effet: formData.effet as any,
            type: formData.type as any
          })
          
          setShowSuccess(true)
          console.log('Nouvelle séquence créée:', newSequence)
          
          setTimeout(() => {
            setShowSuccess(false)
            router.push('/sequences')
          }, 1000)
        }
      }
    } catch (error) {
      console.error('Erreur lors de la sauvegarde de la séquence:', error)
      toast.error('Erreur lors de la sauvegarde de la séquence', {
        id: loadingToast,
      })
    }
  }

  const renderStepContent = () => {
    // Utiliser l'ID de séquence créée ou fourni en prop
    const currentSequenceId = createdSequenceId || sequenceId
    
    switch (currentStep) {
      case "Général":
        return (
          <GeneralStep 
            formData={formData} 
            setFormData={setFormData}
            showSuccess={showSuccess}
            sequenceId={currentSequenceId}
            onTitleChange={handleTitleChange}
          />
        )
      case "Rôle":
        return <RoleStep sequenceId={currentSequenceId} />
      case "Costume":
        return <CostumeStep sequenceId={currentSequenceId || ''} />
      case "Accessoire":
        return <AccessoireStep sequenceId={currentSequenceId || ''} />
      case "Effets spéciaux":
        return <EffetsSpeciauxStep sequenceId={currentSequenceId || ''} />
      case "Équipe technique":
        return <EquipesTechniquesStep sequenceId={currentSequenceId || ''} />
      case "Son":
        return <SonStep sequenceId={currentSequenceId || ''} />
      case "Machinerie":
        return <MachinerieStep sequenceId={currentSequenceId || ''} />
      default:
        return <GeneralStep formData={formData} setFormData={setFormData} showSuccess={showSuccess} sequenceId={currentSequenceId} />
    }
  }

  return (
    <FooterProvider>
      <div className="bg-slate-800 rounded-lg h-full flex flex-col">
        {/* Header */}
        <div className="flex-shrink-0 p-4 md:p-6 border-b border-slate-600">
          <div className="flex items-center justify-between">
            <StepHeader
              current={currentStep}
              steps={STEPS}
              onSelect={goTo}
              onClose={onCancel}
            />
          </div>
        </div>

        {/* Content - Scrollable */}
        <div className="flex-1 overflow-y-auto p-4 md:p-6">
          {renderStepContent()}
        </div>

        {/* Footer */}
        <div className="flex-shrink-0 p-4 md:p-6 border-t border-slate-600">
          <StepFooter
            currentIndex={currentIndex}
            total={STEPS.length}
            onPrev={goPrev}
            onNext={goNext}
            onSubmit={handleSubmit}
            editMode={editMode}
          />
        </div>
      </div>
    </FooterProvider>
  )
}